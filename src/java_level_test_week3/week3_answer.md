**1. Java에서 선언 위치에 따른 변수의 종류를 모두 작성하세요.**

- `클래스(또는 static) 변수`: 클래스가 로딩될 때 같이 생성되며, 클래스의 모든 인스턴스들이 공유하게 되는 변수
- `인스턴스 변수`: 클래스로부터 생성된 인스턴스마다 독립적으로 가지는 변수
- `지역 변수`: 메서드 내부나 블록 {} 내부에 선언되며 사용 범위는 해당 블록 내부로 제한되는 변수

---

**2. JVM의 메모리 구조 중 다음 각 영역에 대해 설명하세요.**

- `메서드 (Method Area)`: 클래스 정보, 전역 변수, static 변수, 메서드 정보 등 JVM이 읽어들인 프로그램의 바이트 코드가 저장되는 영역
- `힙 (Heap)`: 객체와 배열이 생성되는 영역. new 키워드를 사용하여 생성된 인스턴스와 배열이 저장되는 공간
- `스택 (Call Stack)`: 메서드의 호출과 실행에 따른 런타임 스택이 생성되는 영역. 지역 변수, 파라미터, 메서드 정보, 연산 중 생기는 임시 데이터 등이 저장되는 공간

---

**3. 다음 중 메서드 오버로딩에 대한 올바른 설명을 모두 고르세요.**

- (1) 하나의 클래스 내에서 같은 이름의 메서드를 여러 개 정의하는 것을 말한다.
- (2) 메서드의 반환 타입은 구별 요인으로 사용될 수 없다.
- ~~(3) 항상 새로운 메서드를 생성해야 하는 것을 말한다.~~
- (4) 메서드의 파라미터의 개수, 타입, 순서는 구별 요인으로 사용될 수 있다.
- ~~(5) 부모 클래스의 메서드를 자식 클래스에서 재정의하는 것을 말한다.~~

---

**4. 다음 중 생성자(Constructor)에 대한 올바른 설명을 모두 고르세요.**

- ~~(1) 생성자의 이름은 클래스의 이름과 다를 수 있다.~~
- (2) 생성자는 객체가 생성될 때 호출되며, 주로 인스턴스 변수의 초기화에 사용된다.
- ~~(3) 클래스에서 생성자를 명시적으로 선언하지 않으면 생성자를 사용할 수 없다.~~
- (4) 생성자는 반환 타입을 가지지 않는다.
- (5) 생성자는 객체 생성 시 필요한 코드를 실행하는 데 사용된다.

---

**5. 인스턴스 생성 시, 다음 각 타입의 멤버 변수가 기본적으로 초기화되는 값을 작성하세요.**

| **타입**    | **초기값** |
|-----------|---------|
| `int`     | 0       |
| `double`  | 0.0     |
| `String`  | null    |
| `boolean` | false   |
| 참조형       | null    |

---

**6. 메서드 오버라이딩에 대한 올바른 설명을 모두 고르세요.**

- (1) 메서드 오버라이딩은 부모 클래스에 있는 메서드를 자식 클래스에서 재정의하는 것을 의미한다.
- (2) 오버라이딩된 메서드는 부모 클래스의 메서드와 이름, 파라미터 타입, 파라미터 개수가 모두 동일해야 한다.
- ~~(3) 부모 클래스의 메서드보다 더 많은 수의 예외를 선언할 수 있다.~~
- ~~(4) 오버라이딩된 메서드는 부모 클래스의 메서드보다 접근 범위가 좁아질 수 있다.~~
- (5) 메서드 오버라이딩은 클래스의 다형성을 보장하는 중요한 기능 중 하나다.

---

**7. `final`과 `abstract`에 대한 올바른 설명을 모두 고르세요.**

- ~~(1) `final` 클래스는 다른 클래스에 의해 상속될 수 있다.~~
- ~~(2) `abstract` 클래스는 모든 메서드가 반드시 추상 메서드여야 한다.~~
- ~~(3) `final` 클래스는 변경이 불가능한 클래스이며, 모든 멤버 변수도 반드시 `final`이어야 한다.~~
- (4) `abstract` 클래스는 직접 객체를 생성할 수 없다.
- (5) `final` 클래스의 메서드는 자식 클래스에서 오버라이딩이 불가능하다.

---

**8. 다음과 같이 정의된 클래스들에 대한 올바른 설명을 모두 고르세요.**

```java
public abstract class Parent {

    final int num = 10;

    abstract void greet();

    final void farewell() {
        System.out.println("Goodbye!");
    }
}

public class Child extends Parent {

    void greet() {
        System.out.println("Hello!");
    }
}
```

- ~~(1) `Child` 클래스는 `Parent` 클래스를 상속 받으므로, `farewell` 메서드를 오버라이딩 할 수 있다.~~
- (2) `Parent`에서 선언된 `greet` 메서드는 추상 메서드로, `Child` 클래스에서 반드시 구현해야 한다.
- ~~(3) `Child` 클래스에서 `Parent` 클래스에 선언된 `num` 변수의 값을 변경할 수 있다.~~
- (4) `Child` 클래스 객체를 생성하여 `farewell` 메서드를 호출하면 `"Goodbye!"` 메시지가 출력된다.
- (5) `Child` 클래스에서는 `Parent` 클래스의 추상 메서드인 `greet`를 오버라이딩 했다.

---

**9. 다음과 같이 정의된 인터페이스와 구현 클래스에 대한 올바른 설명을 모두 고르세요.**

```java
public interface Runner {

    protected int speed = 50;

    void run();

    default void stop() {
        System.out.println("Stop!");
    }
}

public class Sprinter extends Runner {

    public void run() {
        System.out.println("Sprinter Running!");
    }
}

public class Marathoner implements Runner {

    public void run() {
        System.out.println("Marathoner Running!");
    }
}
```

- ~~(1) `Sprinter`, `Marathoner` 클래스 모두 `Runner` 인터페이스를 구현하는 클래스이다.~~
- ~~(2) `speed` 변수의 접근 제어자가 `protected`이므로, `Runner` 인터페이스를 구현한 모든 클래스에서 `speed` 변수를 사용할 수 있다.~~
- (3) `Runner` 인터페이스를 구현한 모든 클래스는 `Runner` 인터페이스의 `run` 메서드를 반드시 구현해야 한다.
- ~~(4) `Runner` 인터페이스를 구현한 모든 클래스는 `Runner` 인터페이스의 `stop` 메서드를 반드시 구현해야 한다.~~
- (5) `Marathoner` 클래스에서 `stop` 메서드를 호출하면 콘솔 창에 `"Stop!"`이 출력된다.
